server:
  extraFlags:
    - web.enable-lifecycle 
  ingress:
    enabled: true
    ingressClassName: nginx
    annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/ssl-passthrough: "true"
        nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    hosts:
      - prom.mishap.local
  
  persistentVolume:
    enabled: true
    size: 8Gi
    storageClass: csi-hostpath-sc     # multi-node minikube
    # storageClass: gp3               # EKS
  
  securityContext:
    runAsNonRoot: true
    allowPrivilegeEscalation: false
  
serverFiles:
  alerting_rules.yml:
    groups:
      - name: node_exporter_alert
        rules:
          - record: job_instance_mode:node_cpu_seconds:avg_rate5m
            expr: avg by (job, instance, mode) (rate(node_cpu_seconds_total[5m]))
      
          - alert: InstanceDown
            expr: up == 0
            for: 5m
            labels:
              severity: instance_down
            annotations:
              description: '{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.'
              summary: 'Instance {{ $labels.instance }} is down'

extraScrapeConfigs: |
  - job_name: 'local-business-pods'
    kubernetes_sd_configs:
      - role: pod
        namespaces:
          names: ["app"]
    relabel_configs:
      # keep only pods with label app.kubernetes.io/name=local-business
      - action: keep
        source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
        regex: local-business
      # keep containers that expose a port named "metrics"
      # - action: keep
        # source_labels: [__meta_kubernetes_pod_container_port_name]
        # regex: metrics
      # set address to <podIP>:<containerPort> (covers IPv4/IPv6)
      - action: replace
        source_labels: [__meta_kubernetes_pod_ip, __meta_kubernetes_pod_container_port_number]
        target_label: __address__
        regex: (.+);(.+)
        replacement: $1:$2
    metrics_path: /metrics
    scheme: http